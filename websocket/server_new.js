const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const axios = require('axios');

const config = require('./config');
const { handleSocketEvents, deviceCache } = require('./socketHandlers');
const { getAllQueueStatus, clearDeviceQueue } = require('./queueManager');
const db = require('./database');
const { devices, deviceRooms, setDeviceBusy, releaseDevice, isDeviceBusy, getDeviceStatus, startHeartbeatCheck } = require('./deviceManager');
const { updateDeviceOnlineStatus, getDeviceConfigId, getProfitConfigPreview } = require('./database');

const app = express();
const server = http.createServer(app);

// ÈÖçÁΩÆCORS
app.use(cors({
    origin: config.corsOrigins,
    credentials: true
}));

// ‚úÖ Áªü‰∏ÄÊúçÂä°Á´Ø Socket.IO ÂàùÂßãÂåñÔºåÊâìÂºÄ EIO3 ÂÖºÂÆπÂπ∂ÊåáÂÆöË∑ØÂæÑ/‰º†Ëæì
const io = socketIo(server, {
    cors: {
        origin: config.corsOrigins,
        methods: ['GET', 'POST'],
        credentials: true
    },
    // ÂÖºÂÆπÊóßÁâà Android Java ÂÆ¢Êà∑Á´ØÔºàengine.io v3Ôºâ
    allowEIO3: true,
    // ÊòéÁ°ÆËÆæÁΩÆ‰º†Ëæì‰∏éÂøÉË∑≥ÂèÇÊï∞ÔºàÊù•Ëá™ config.socketOptions ÊàñÈªòËÆ§ÂÄºÔºâ
    transports: (config.socketOptions && config.socketOptions.transports) ? config.socketOptions.transports : ['websocket', 'polling'],
    pingInterval: (config.socketOptions && config.socketOptions.pingInterval) ? config.socketOptions.pingInterval : 25000,
    pingTimeout: (config.socketOptions && config.socketOptions.pingTimeout) ? config.socketOptions.pingTimeout : 120000,
    connectionStateRecovery: (config.socketOptions && config.socketOptions.connectionStateRecovery) ? config.socketOptions.connectionStateRecovery : { maxDisconnectionDuration: 120000, skipMiddlewares: true },
    perMessageDeflate: (config.socketOptions && typeof config.socketOptions.perMessageDeflate !== 'undefined') ? config.socketOptions.perMessageDeflate : false,
    // ÊúçÂä°Á´ØÁªü‰∏ÄË∑ØÂæÑÔºà‰∏éÂÆ¢Êà∑Á´Ø BuildConfig.SOCKET_PATH ‰øùÊåÅ‰∏ÄËá¥Ôºâ
    path: '/socket.io/'
});

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Âü∫Á°ÄË∑ØÁî±
app.get('/', (req, res) => {
    res.json({ 
        message: 'TV Game WebSocket Server',
        status: 'running',
        timestamp: new Date().toISOString()
    });
});

// ÂÅ•Â∫∑Ê£ÄÊü•Á´ØÁÇπ
app.get('/health', (req, res) => {
    res.json({
        status: 'healthy',
        uptime: process.uptime(),
        timestamp: new Date().toISOString()
    });
});

// --- ÂêØÂä®Êó∂ÂÖ®ÈáèÈ¢ÑÁÉ≠ËÆæÂ§áÁºìÂ≠ò ---
async function preloadDeviceConfigs() {
    console.log('üöÄ ÂºÄÂßãÈ¢ÑÁÉ≠ËÆæÂ§áÈÖçÁΩÆÁºìÂ≠ò...');
    let connection;
    try {
        connection = await db.pool.getConnection();
        // ‰ªé device_price_bind ËØªÂèñÂêÑËÆæÂ§áÂΩìÂâçÂêØÁî®ÁöÑ‰ª∑Ê°£Ôºàtier_idÔºâ
        const [rows] = await connection.execute(
            `SELECT device_id, tier_id FROM device_price_bind WHERE status = 1 ORDER BY start_time DESC`
        );
        let loaded = 0;
        const seen = new Set();
        for (const row of rows) {
            const device_id = row.device_id;
            if (seen.has(device_id)) continue; // ‰ªÖÂèñÊØèËÆæÂ§áÊúÄÊñ∞‰∏ÄÊù°
            seen.add(device_id);
            const config_id_raw = row.tier_id;
            const config_id = config_id_raw === null ? null : parseInt(config_id_raw, 10);
            if (!config_id || Number.isNaN(config_id)) continue;
            const [cfgRows] = await connection.execute(
                'SELECT price, profit_json FROM lottery_price_tier WHERE tier_id = ? LIMIT 1',
                [config_id]
            );
            if (cfgRows && cfgRows[0]) {
                let profitCfg;
                try { profitCfg = JSON.parse(cfgRows[0].profit_json || '{}'); } catch (_) { profitCfg = {}; }
                const supplier = (profitCfg.prizes && Array.isArray(profitCfg.prizes.supplier)) ? profitCfg.prizes.supplier : [];
                const merchant = (profitCfg.prizes && Array.isArray(profitCfg.prizes.merchant)) ? profitCfg.prizes.merchant : [];
                const totalCount = supplier.length + merchant.length;
                deviceCache[device_id] = {
                    config_id,
                    config: {
                        config_name: profitCfg.name || '',
                        lottery_amount: parseFloat(cfgRows[0].price || 0),
                        prizes: { supplier: { type: 'supplier', data: supplier }, merchant: { type: 'merchant', data: merchant } }
                    },
                    updated_at: new Date(),
                };
                loaded++;
                console.log(`‚úÖ È¢ÑÁÉ≠ËÆæÂ§áÁºìÂ≠ò ${device_id} ‚Üí ‰ª∑Ê°£ID=${config_id} (Â•ñÂìÅ${totalCount}È°π)`);
            }
        }
        console.log(`üöÄ È¢ÑÁÉ≠ÂÆåÊàêÔºåÂÖ±Âä†ËΩΩ ${loaded} Âè∞ËÆæÂ§á„ÄÇ`);
    } catch (err) {
        console.error('‚ùå È¢ÑÁÉ≠ËÆæÂ§áÈÖçÁΩÆÁºìÂ≠òÂ§±Ë¥•:', err);
    } finally {
        if (connection) connection.release();
    }
}

// ÊäΩÂ•ñÂêØÂä®HTTPÂÖ•Âè£ÔºàÂÖºÂÆπ‰∏§ÁßçË∑ØÂæÑÔºâ
async function handleStartLottery(req, res) {
    try {
        const { device_id, config_id, order_id, amount, user_id, openid, lottery_type = 1, user_name = '' } = req.body || {};

        if (!device_id) {
            return res.status(400).json({ success: false, message: 'Áº∫Â∞ëdevice_id' });
        }

        // Êü•ÊâæËÆæÂ§áÊàøÈó¥
        const roomName = deviceRooms.get(device_id) || `device_${device_id}`;

        // ËæÖÂä©ÔºöÊåâËÆæÂ§áIDÊü•ÊâæËÆæÂ§á‰ø°ÊÅØ
        const getDeviceInfoByDeviceId = (deviceId) => {
            for (const [, info] of devices.entries()) {
                if (info && info.device_id === deviceId) return info;
            }
            return null;
        };

        const devInfo = getDeviceInfoByDeviceId(device_id);
        let cfgId = parseInt(config_id, 10);
        if (Number.isNaN(cfgId) || cfgId <= 0) {
            const boundCfg = devInfo && devInfo.config_id ? devInfo.config_id : (await getDeviceConfigId(device_id));
            cfgId = boundCfg || 26; // ÊúÄÁªàÂõûÈÄÄÂà∞26
        }

        // Êé®ÈÄÅÂàÜÊ∂¶ÈÖçÁΩÆÈ¢ÑËßàÔºå‰øùËØÅÂâçÁ´Ø‰∏ÄËá¥
        try {
            const preview = await getProfitConfigPreview(cfgId);
            if (preview) {
                io.to(roomName).emit('config_preview', preview);
            }
        } catch (e) {
            console.warn('‚ö†Ô∏è Ëé∑ÂèñÂàÜÊ∂¶ÈÖçÁΩÆÈ¢ÑËßàÂ§±Ë¥•Ôºö', e.message);
        }

        // Â∞ÜÊäΩÂ•ñËØ∑Ê±ÇÂπøÊí≠Âà∞ÊåáÂÆöËÆæÂ§áÊàøÈó¥ÔºàÂåÖÂê´ÊóßÂÆ¢Êà∑Á´ØÂà´ÂêçÂ≠óÊÆµÔºâ
        io.to(roomName).emit('lottery_start', {
            device_id,
            config_id: cfgId,
            order_id,
            orderId: order_id, // ÊóßAndroidÂÆ¢Êà∑Á´ØÂèØËÉΩËØªÂèñËØ•Â≠óÊÆµ
            amount,
            user_id,
            openid,
            lottery_type,
            user_name,
            timestamp: new Date().toISOString()
        });

        return res.json({ success: true, message: 'lottery start pushed', device_id, config_id: cfgId });
    } catch (error) {
        console.error('‚ùå ÊäΩÂ•ñÂêØÂä®Â§±Ë¥•:', error);
        return res.status(500).json({ success: false, message: error.message || 'server error' });
    }
}

// ÂÖºÂÆπÊóßÊé•Âè£Ë∑ØÂæÑ
app.post('/api/start-lottery', handleStartLottery);
app.post('/lottery-start', handleStartLottery);

// Socket.IO ËøûÊé•‰∫ã‰ª∂
io.on('connection', (socket) => {
    console.log(`‚ö° ÂÆ¢Êà∑Á´ØËøûÊé•: ${socket.id}`);

    // ÁªëÂÆö‰∫ã‰ª∂Â§ÑÁêÜ
    handleSocketEvents(io, socket);
});

module.exports = { server, io, preloadDeviceConfigs };

// Ëé∑ÂèñËÆæÂ§áÈòüÂàóÁä∂ÊÄÅÁöÑAPI
app.get('/api/queue-status', (req, res) => {
    try {
        const queueStatus = getAllQueueStatus();
        return res.json({ 
            success: true, 
            data: queueStatus,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('‚ùå Ëé∑ÂèñÈòüÂàóÁä∂ÊÄÅÂ§±Ë¥•:', error);
        return res.status(500).json({ success: false, message: error.message || 'server error' });
    }
});

// Ê∏ÖÁ©∫ËÆæÂ§áÈòüÂàóÁöÑAPIÔºàÁ¥ßÊÄ•ÊÉÖÂÜµ‰ΩøÁî®Ôºâ
app.post('/api/clear-device-queue', (req, res) => {
    try {
        const { device_id } = req.body || {};
        if (!device_id) {
            return res.status(400).json({ success: false, message: 'Áº∫Â∞ë device_id' });
        }
        
        clearDeviceQueue(device_id);
        console.log(`üßπ ÁÆ°ÁêÜÂëòÊ∏ÖÁ©∫ËÆæÂ§á${device_id}ÈòüÂàó`);
        
        return res.json({ 
            success: true, 
            message: `ËÆæÂ§á${device_id}ÈòüÂàóÂ∑≤Ê∏ÖÁ©∫`
        });
    } catch (error) {
        console.error('‚ùå Ê∏ÖÁ©∫ËÆæÂ§áÈòüÂàóÂ§±Ë¥•:', error);
        return res.status(500).json({ success: false, message: error.message || 'server error' });
    }
});

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Ëé∑ÂèñÂú®Á∫øËÆæÂ§á‰ø°ÊÅØ - ÁªôÂêéÁ´ØÁÆ°ÁêÜÁ≥ªÁªü‰ΩøÁî®
app.get('/devices', (req, res) => {
    try {
        const onlineDevices = [];
        
        // Â∞Üdevices MapËΩ¨Êç¢‰∏∫Êï∞ÁªÑÊ†ºÂºè
        for (const [socketId, deviceInfo] of devices.entries()) {
            onlineDevices.push({
                device_id: deviceInfo.device_id,
                connected_at: deviceInfo.registered_at.toISOString(),
                last_heartbeat: deviceInfo.last_heartbeat.toISOString(),
                device_type: deviceInfo.device_type || 'unknown',
                socket_id: socketId,
                device_name: deviceInfo.device_name || ''
            });
        }
        
        res.json({
            success: true,
            count: onlineDevices.length,
            devices: onlineDevices,
            timestamp: new Date().toISOString()
        });
        
        console.log(`üìä ËøîÂõûÂú®Á∫øËÆæÂ§á‰ø°ÊÅØ: ${onlineDevices.length}Âè∞ËÆæÂ§á`);
    } catch (error) {
        console.error('‚ùå Ëé∑ÂèñËÆæÂ§á‰ø°ÊÅØÂ§±Ë¥•:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            devices: []
        });
    }
});

const PORT = config.port;
server.listen(PORT, '0.0.0.0', () => {
    console.log(`üöÄ WebSocket ÊúçÂä°Âô®ÂêØÂä®Âú®Á´ØÂè£ ${PORT}`);
    console.log('üîß CORS Origins:', config.corsOrigins);
    console.log('üîß Socket Options:', {
        transports: (config.socketOptions && config.socketOptions.transports) ? config.socketOptions.transports : ['websocket', 'polling'],
        pingInterval: (config.socketOptions && config.socketOptions.pingInterval) ? config.socketOptions.pingInterval : 25000,
        pingTimeout: (config.socketOptions && config.socketOptions.pingTimeout) ? config.socketOptions.pingTimeout : 120000,
        path: '/socket.io/'
    });

    // ÂêØÂä®ÂøÉË∑≥Ê£ÄÊü•
    try {
        startHeartbeatCheck(io);
        console.log('‚ù§Ô∏è ÂøÉË∑≥Ê£ÄÊü•Â∑≤ÂêØÂä®');
    } catch (e) {
        console.warn('‚ö†Ô∏è ÂêØÂä®ÂøÉË∑≥Ê£ÄÊü•Â§±Ë¥•Ôºö', e.message);
    }

    // ÂêØÂä®Êó∂È¢ÑÁÉ≠ÈÖçÁΩÆÁºìÂ≠ò
    preloadDeviceConfigs().catch(err => console.warn('‚ö†Ô∏è È¢ÑÁÉ≠Â§±Ë¥•Ôºö', err.message));
});

process.on('uncaughtException', (err) => {
    console.error('‚ùå Êú™ÊçïËé∑ÂºÇÂ∏∏:', err);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Êú™Â§ÑÁêÜÁöÑ Promise ÊãíÁªù:', reason);
});

process.on('SIGTERM', () => {
    console.log('üõë Êî∂Âà∞ SIGTERMÔºåÂáÜÂ§áÂÖ≥Èó≠ÊúçÂä°Âô®...');
    server.close(() => {
        console.log('‚úÖ ÊúçÂä°Âô®Â∑≤ÂÖ≥Èó≠');
        process.exit(0);
    });
});

process.on('SIGINT', () => {
    console.log('üõë Êî∂Âà∞ SIGINTÔºàCtrl+CÔºâÔºåÂáÜÂ§áÂÖ≥Èó≠ÊúçÂä°Âô®...');
    server.close(() => {
        console.log('‚úÖ ÊúçÂä°Âô®Â∑≤ÂÖ≥Èó≠');
        process.exit(0);
    });
});

module.exports = { app, server, io };

// È¢ùÂ§ñÁÆ°ÁêÜÊé•Âè£ÔºöÊ∏ÖÈô§ËÆæÂ§áÂøôÁ¢å/Áä∂ÊÄÅÔºàÁî®‰∫éÁ¥ßÊÄ•ÊÅ¢Â§çÔºâ
app.post('/api/clear-device-status', (req, res) => {
    try {
        const { device_id } = req.body || {};
        if (!device_id) {
            return res.status(400).json({ success: false, message: 'Áº∫Â∞ë device_id' });
        }
        releaseDevice(device_id);
        return res.json({ success: true, message: `ËÆæÂ§á ${device_id} Áä∂ÊÄÅÂ∑≤Ê∏ÖÈô§` });
    } catch (error) {
        return res.status(500).json({ success: false, message: error.message || 'server error' });
    }
});

// ÂπøÊí≠ÊµãËØïÊé•Âè£
app.post('/api/broadcast', (req, res) => {
    try {
        const { event = 'test_event', payload = {} } = req.body || {};
        io.emit(event, payload);
        return res.json({ success: true, message: 'broadcasted', event });
    } catch (error) {
        return res.status(500).json({ success: false, message: error.message || 'server error' });
    }
});

// -------------------- ÊäΩÂ•ñËÅîË∞ÉÁºñÊéíÔºàËÆ¢Âçï‚ÜíÊîØ‰ªòÂõûË∞É‚ÜíÊäΩÂ•ñÔºâ --------------------
// POST /api/turntable/draw-flow
// body: { device_sn?|device_id?, tier_id, site_id? }
// header: Authorization: Bearer <member token>
// ÊµÅÁ®ãÔºöË∞ÉÁî® PHP create ‚Üí ‰ΩøÁî®ËøîÂõû attach Ë∞ÉÁî® paynotify ‚Üí Áõ¥Êé•ËøîÂõû paynotify ÁöÑÊäΩÂ•ñÁªìÊûú
app.post('/api/turntable/draw-flow', async (req, res) => {
    // ËßÑËåÉ API Âü∫ÂùÄÔºöÂéªÈô§Â§ö‰Ωô /api ÂâçÁºÄÔºåÁ°Æ‰øù /addons Ë∑ØÁî±ÂèØËææ
    let apiBase = (config.apiBaseUrl || '').replace(/\/$/, '');
    if (apiBase.endsWith('/index.php/api')) apiBase = apiBase.slice(0, -4); // ÂéªÊéâÊú´Â∞æ /api
    else if (apiBase.endsWith('/api')) apiBase = apiBase.slice(0, -4);      // ÂéªÊéâÊú´Â∞æ /api
    const createUrl = `${apiBase}/addons/device_turntable/api/order/create`;
    const notifyUrl = `${apiBase}/addons/device_turntable/api/order/paynotify`;

    const { device_sn = '', device_id = 0, tier_id = 0, site_id = 0 } = req.body || {};
    const auth = req.headers['authorization'] || '';
    // ÊîØÊåÅ‰ªé Authorization: Bearer <token> Êàñ body.token ÊèêÂèñ token
    const tokenFromHeader = auth.replace(/^Bearer\s+/i, '');
    const token = (req.body && req.body.token) ? String(req.body.token) : (tokenFromHeader || '');

    if ((!device_sn && !device_id) || !tier_id) {
        return res.status(400).json({ code: -1, msg: 'Áº∫Â∞ëÂøÖË¶ÅÂèÇÊï∞: device_sn|device_id Êàñ tier_id' });
    }
    if (!token) {
        return res.status(401).json({ code: -1, msg: 'Áº∫Â∞ë‰ºöÂëò tokenÔºàËØ∑ÂÖàÁôªÂΩïËé∑Âèñ tokenÔºâ' });
    }

    try {
        // 1) ÂàõÂª∫ÊäΩÂ•ñÊîØ‰ªòËÆ¢ÂçïÔºàÈúÄË¶Å‰ºöÂëò tokenÔºâ
        const createResp = await axios.post(createUrl, { token, device_sn, device_id, tier_id, site_id });
        const cdata = (createResp.data && createResp.data.data) || {};
        if (!cdata.order_no || !cdata.attach) {
            return res.status(500).json({ code: -1, msg: 'ÂàõÂª∫ËÆ¢ÂçïÂ§±Ë¥•', data: createResp.data });
        }

        // 2) Ê®°ÊãüÊîØ‰ªòÊàêÂäüÂõûË∞É ‚Üí Ëß¶ÂèëÊäΩÂ•ñ
        const payload = {
            order_no: cdata.order_no,
            total_amount: cdata.amount || 0,
            trade_status: 'success',
            attach: cdata.attach
        };

        // ÂèØÈÄâÔºöÁ≠æÂêçÔºàÂΩìÂêéÁ´ØÈÖçÁΩÆ LOTTERY_PAY_SECRET Êó∂Ôºâ
        const secret = process.env.LOTTERY_PAY_SECRET || '';
        if (secret) {
            const ts = Math.floor(Date.now() / 1000);
            const raw = `${payload.order_no}|${Number(payload.total_amount).toFixed(2)}|${payload.trade_status}|${ts}`;
            const crypto = require('crypto');
            const sign = crypto.createHmac('sha256', secret).update(raw).digest('hex');
            payload.ts = ts;
            payload.sign = sign;
        }

        const notifyResp = await axios.post(notifyUrl, payload);
        return res.json(notifyResp.data);
    } catch (err) {
        const status = err.response && err.response.status;
        const data = err.response && err.response.data;
        console.error('‚ùå ÊäΩÂ•ñËÅîË∞ÉÂ§±Ë¥•:', status, data || err.message);
        return res.status(status || 500).json(data || { code: -1, msg: err.message || 'server error' });
    }
});